# Содержание:
- [Введение](#введение)
- [Реализация vector](#реализация-вектора)
- [Реализация умных указателей](#реализация-умных-указателей)
  - [unique_ptr](#unique_ptr)


# Введение
Всё, что будет здесь реализовано, было вдохновлено курсом лекций от преподавателя МФТИ - Ильи Мещерина: https://www.youtube.com/playlist?list=PLmSYEYYGhnBviRYhIDty-CSTDS16a3whl, пользуясь случаем хотел бы выразить ему большую благодарность за столь подробную и доступную подачу материала.
За основу я буду брать документацию https://en.cppreference.com/w/cpp/container/vector.html, и стараться воспроизвести функции, которые там описаны, по возможности стараясь давать те же гарантии безопастости, такую же эффективность и интерфейс, насколько это возможно.



# Реализация vector

Я не ставлю перед собой цель реализовать вектор точно как в stl, а скорее хочу поделиться тем, как я попытался реализовать его подобие, по духу близкое к оригиналу.

Дополнительно я реализовал `reverse_iterator` и `back_insert_iterator`, а таже подобие стандартного `std::allocator<T>`.

Замечание: по хорошему реализация класса `base_iterator` должна находиться внутри вектора, поскольку мы не хотим давать возможность создания объектов этого класса без явного указания контейнера, однако для большей читаемости я вынес реализацию этого класса в отдельный файл


# Реализация умных указателей

В этом разделе я постараюсь достаточно кратно рассказать про мотивацию появления умнных указателей (smart pointers), а также про особенности каждого из них. Я постараюсь быть краток, в сущности все умные указатели из стандартной библиотеки (`unique_ptr`, `shared_ptr`, `weak_ptr`) реализуют идиому RAII (Resource Acquisition Is Initialization) для управления динамической памятью: ресурс (память) выделяется при создании объекта, а освобождается автоматически при его уничтожении. Это делает работу с памятью безопасной и избавляет от необходимости вручную вызывать `delete`. Но в тоже время каждый из них имеет свои особенности и случаи использования.

## unique_ptr

`unique_ptr` — это умный указатель в C++, предназначенный для автоматического управления динамической памятью. Он решает следующие проблемы:

- Утечки памяти: `unique_ptr` автоматически освобождает память, когда выходит из области видимости, предотвращая утечки.
- Явное владение: Объектом может владеть только один `unique_ptr` — это исключает двойное удаление и ошибки с несколькими владельцами.
- Безопасность: Запрещено копировать `unique_ptr`, только перемещать, что делает владение ресурсом явным и безопасным.

Основная идея реализации:
`unique_ptr` хранит обычный указатель и удаляет объект через деструктор, используя оператор `delete` (или пользовательский `deleter`). Копирование запрещено, разрешено только перемещение (move semantics), что гарантирует уникальное владение ресурсом.

На самом деле наивная реализация `unique_ptr` достотачно очевидная, но поскольку я хотел бы приблизиться к стандартной библиотеке, стоит оговориться, что в стандартной библиотеке `unique_ptr` имеет два шаблонных параметра: тип управляемого объекта (T) и тип функции удаления (deleter). При том поначалу назначение второго праметра может показаться неочевидным, про это я как раз и хочу поговорить ниже.

Как мог могла бы выгвядеть наивная реализая деструктора:
```c++
~unique_ptr() {
    delete ptr;
}
```

Но тут же возникает вопрос, а что если мы выделяли память не через `new`, а через `new[]`? Ну на самом деле вновь ничего критичного, просто можно написать специализацию шаблона для массивов, что-то в духе такого:
```c++
template <typename T> 
class unique_ptr;

template <typename T> 
class unique_ptr<T[]>;
```

Но и это не решает проблему полностью, ведь что если мы выделяли память не через `new`, а через `malloc`? В этом случае нам нужно использовать `free` вместо `delete`. Может у нас есть какой-то пользовательский аллокатор, который требует вызова своей функции освобождения памяти, ну или наконец мы иогли открыть сетевое соединение, и нам нужно вызвать `close` для его закрытия. В общем случаев может быть много, и чтобы покрыть их все, в стандартной библиотеке решили сделать второй шаблонный параметр, который по умолчанию является `std::default_delete<T>`, но его можно переопределить на любой другой тип функции удаления.

Таким образом, деструктор `unique_ptr` в стандартной библиотеке может выглядеть примерно так:
```c++
template <typename T,typename Deleter = std::default_delete<T>> 
class unique_ptr;

// Специализация для массивов всё же необходима, по причине разного интерфейса, который мы хотим предоставлять к объектам разных типов - к примеру операторы * и -> должны быть реализованы только для одиночных объектов
template <typename T, typename Deleter> 
class unique_ptr<T[], Deleter>;
```

И для обращения к функци удаления мы должны хранить объект типа `Deleter` внутри `unique_ptr`, и вызывать его в деструкторе. 

Далее поговорим о том, что вообще представляет из себя `std::default_delete<T>`: это функциональный объект (функтор), который определён в заголовочном файле `<memory>`. Он предназначен для использования с умными указателями, такими как `std::unique_ptr`, чтобы обеспечить безопасное удаление объектов, на которые они указывают. Для начала реализуем общий случай для одиночных объектов:
```c++
template <typename T>
struct default_delete {
    using pointer = T*;
    using element_type = T;

    constexpr default_delete() noexcept = default;

    // Наличие requires позволяет присваивать default_delete<Base> к default_delete<Derived>
    template <typename U>
    requires std::convertible_to<U*, T*>
    default_delete(const default_delete<U>&) noexcept {}

    // static_assert(sizeof(T) > 0) — предотвращает удаление неполных типов
    void operator()(T* ptr) const noexcept {
        static_assert(sizeof(T) > 0);
        delete ptr;
    }
}; 
```

В целом `default_delete` — это просто обёртка вокруг оператора `delete`. Также отмечу, что `default_delete` - Stateless объект, то есть не хранит никакого состояния, тогда move или copy — фактически одно и то же, а все сложные требования к конструкторам и шаблонным параметрам deleter нужны только для stateful deleter’ов - хранящим какое-то состояние.

Также у класса `default_delete` есть специализация для массивов.

Далее поговорим про один из конструкторов `unique_ptr`:
```c++
template <class U, class E>
constexpr unique_ptr(unique_ptr<U, E>) noexcept;
```

Этот конструктор позволяет перемещать совместимые unique_ptr с разными параметрами.Это необходимо по нескольким причинам:
- Полиморфизм: чтобы можно было безопасно «переводить» `unique_ptr<Derived>` в `unique_ptr<Base>`
- Универсальность: чтобы `unique_ptr<T, Deleter1>` можно было переместить в `unique_ptr<T, Deleter2>`, если deleter’ы совместимы.
Без этого конструктора мы могли бы перемещать только идентичные `unique_ptr<T, Deleter>` -> `unique_ptr<T, Deleter>`

При этом стоит помнить, что этот конструктор должен быть доступен только если:
- `U*` неявно преобразуется в `T*`
- `E` может быть сконструирован из `Deleter`

Первое требование выглядит весьма очевидным, в то время как второе лично у меня вызвало некоторые вопросы, поэтому про него я расскажу подробнее:
1) Если `E` совпадает с `Deleter`, то `forward` превращает `other.deleter` (lvalue) в `Deleter&&` (rvalue), таким образом deleter перемещается (в частности это означает, что если `Deleter` не поддерживает перемещение, то и этот конструктор не будет работать)
2) Если `E` и `Deleter` — разные типы, то `forward<E>` корректно приведёт к `E&&`, и уже из него пробуют строить `Deleter`. То есть тут речь не про перемещение, а про "могу ли я построить новый `deleter` из старого"
3) В `requires` мы проверяем существует ли такой конструктор у `Deleter`, который можно вызвать с аргументом типа `E&&`.

Итоговая реализация этого конструктора может выглядеть примерно так:
```c++
template <class U, class E>
requires std::convertible_to<U*, T*> && std::constructible_from<Deleter, E&&>
constexpr unique_ptr(unique_ptr<U, E>&& other) noexcept(std::is_nothrow_constructible_v<Deleter, E&&>) 
: ptr(other.ptr), deleter(std::forward<E>(other.deleter)) {
    other.ptr = nullptr;
}
```

Как мне кажется я рассказал, про наиболее важные моменты, касающиеся реализации `unique_ptr`.